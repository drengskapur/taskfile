# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

silent: true

tasks:
  clean:
    desc: "Clean up the project"
    cmds:
      - rm -rf debug/

  bun:install:
    desc: "Install Bun."
    run: once
    status:
      - command -v bun >/dev/null 2>&1
    cmds:
      - curl -fsSL https://bun.sh/install | bash

  pip:install:
    desc: "Install pip"
    run: once
    status:
      - python3 -m pip --version >/dev/null 2>&1
    cmds:
      - python3 -m ensurepip

  uv:install:
    desc: "Install uv"
    run: once
    status:
      - python3 -m pip show uv >/dev/null 2>&1
    cmds:
      - python3 -m pip install --user --quiet --no-progress uv

  openssl:rand:base64:
    desc: "Generates a base64 encoded token"
    cmds:
      - openssl rand -base64 {{default "32" .length}} | tr -d '\n'

  hadolint:install:
    desc: "Install hadolint"
    run: once
    status:
      - command -v hadolint >/dev/null 2>&1
    cmds:
      - sudo curl -fsSL https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64 -o /usr/local/bin/hadolint
      - sudo chown root:root /usr/local/bin/hadolint
      - sudo chmod +x /usr/local/bin/hadolint
      - hadolint --version

  k3s:install:
    desc: "Install k3s"
    run: once
    status:
      - command -v k3s >/dev/null 2>&1
    cmds:
      - curl -sfL https://get.k3s.io | sh -
      - sudo k3s kubectl get nodes

  rclone:install:
    desc: "Install rclone"
    run: once
    status:
      - command -v rclone >/dev/null 2>&1
    cmds:
      - curl https://rclone.org/install.sh | sudo bash
      - rclone version

  rclone:selfupdate:
    desc: "Self-update rclone to the latest version"
    run: once
    status:
      - rclone selfupdate | grep -q "rclone version"
    cmds:
      - rclone selfupdate
      - echo "rclone has been updated to the latest version."

  fuse:install:
    desc: "Install FUSE (required by rclone)"
    run: once
    status:
      - command -v fusermount >/dev/null 2>&1
    cmds:
      - sudo apt update
      - sudo apt install -y fuse

  rclone:configure-pcloud:
    desc: "Configure rclone remote for pCloud using environment variables"
    run: once
    status:
      - |
        "[ -f "$HOME/.config/rclone/rclone.conf" ] && grep -q "\[pcloud-remote\]" "$HOME/.config/rclone/rclone.conf"
    cmds:
      - mkdir -p "$HOME/.config/rclone"
      - |
        cat <<EOF > "$HOME/.config/rclone/rclone.conf"
        [pcloud-remote]
        type = pcloud
        token = {"access_token":"$PCLOUD_ACCESS_TOKEN","token_type":"Bearer","refresh_token":"$PCLOUD_REFRESH_TOKEN","expiry":"$PCLOUD_EXPIRY"}
        EOF
      - chmod 600 "$HOME/.config/rclone/rclone.conf"
      - echo "Configured pCloud remote in rclone."

  rclone:mount:
    desc: "Mount pCloud using rclone in WSL"
    deps:
      - rclone:install
      - fuse:install
      - rclone:configure-pcloud
      - rclone:create-log-dir
      - rclone:create-mount-point
      - rclone:mount-command
      - rclone:verify-mount

  rclone:create-log-dir:
    desc: "Create log directory if it doesn't exist"
    run: once
    status:
      - |
        [ -d "$HOME/rclone-logs" ]
    cmds:
      - mkdir -p "$HOME/rclone-logs"
      - echo "Created log directory at $HOME/rclone-logs."

  rclone:create-mount-point:
    desc: "Create mount point if it doesn't exist"
    run: once
    status:
      - |
        [ -d "/mnt/pcloud_mount" ]
    cmds:
      - sudo mkdir -p /mnt/pcloud_mount
      - echo "Created mount point at /mnt/pcloud_mount."

  rclone:mount-command:
    desc: "Execute rclone mount command"
    run: once
    status:
      - mount | grep -q "/mnt/pcloud_mount"
    cmds:
      - echo "Mounting pCloud at /mnt/pcloud_mount..."
      - sudo nohup rclone mount \
        "pcloud-remote:Movies" \
        "/mnt/pcloud_mount" \
        --vfs-cache-mode=reads --read-only \
        --allow-other \
        --daemon >> "$HOME/rclone-logs/rclone.log" 2>&1 &
      - echo "$!" > "$HOME/rclone-logs/rclone_pid.txt"
      - echo "Started rclone mount with PID $(cat $HOME/rclone-logs/rclone_pid.txt)."

  rclone:verify-mount:
    desc: "Verify if pCloud was successfully mounted"
    run: once
    cmds:
      - sleep 5
      - |
        if mount | grep -q "/mnt/pcloud_mount"; then
          echo "pCloud successfully mounted at /mnt/pcloud_mount."
          echo "Access this location in Windows using \\\\wsl$\\<Your_Linux_Distribution_Name>\\mnt\\pcloud_mount"
        else
          echo "ERROR: rclone mount failed, please check $HOME/rclone-logs/rclone.log"
          exit 1
        fi

  rclone:unmount:
    desc: "Unmount pCloud using rclone"
    run: once
    status:
      - mount | grep -q "/mnt/pcloud_mount"
    cmds:
      - echo "Unmounting pCloud from /mnt/pcloud_mount..."
      - sudo umount /mnt/pcloud_mount
      - rm -f "$HOME/rclone-logs/rclone_pid.txt"
      - echo "pCloud has been unmounted."

  rclone:cleanup-logs:
    desc: "Clean up old rclone logs"
    run: once
    cmds:
      - find "$HOME/rclone-logs" -type f -mtime +30 -name "*.log" -exec rm {} \;
      - echo "Cleaned up logs older than 30 days."

  rclone:setup-systemd-service:
    desc: "Set up systemd service for automatic rclone mount on WSL startup"
    run: once
    status:
      - |
        [ -f "/etc/systemd/system/rclone-pcloud.service" ]
    cmds:
      - |
        sudo tee /etc/systemd/system/rclone-pcloud.service > /dev/null <<EOF
        [Unit]
        Description=Rclone Mount for pCloud
        After=network-online.target
        Wants=network-online.target

        [Service]
        Type=simple
        ExecStart=/usr/bin/rclone mount pcloud-remote:Movies /mnt/pcloud_mount --vfs-cache-mode=reads --read-only --allow-other
        ExecStop=/bin/fusermount -u /mnt/pcloud_mount
        Restart=on-failure
        User=$(whoami)

        [Install]
        WantedBy=default.target
        EOF
      - sudo systemctl daemon-reload
      - sudo systemctl enable rclone-pcloud.service
      - sudo systemctl start rclone-pcloud.service
      - echo "Systemd service for rclone-pcloud has been set up and started."

  install-terraform:
    desc: "Install terraform"
    run: once
    deps:
      - task: install-jq
    vars:
      LATEST_VERSION:
        sh: curl -s https://api.github.com/repos/hashicorp/terraform/releases/latest | jq -r '.tag_name | ltrimstr("v")'
    cmds:
      - defer: rm -f terraform_{{.LATEST_VERSION}}_linux_amd64.zip
      - defer: rm -f LICENSE.txt
      - |
        curl -LO "https://releases.hashicorp.com/terraform/{{.LATEST_VERSION}}/terraform_{{.LATEST_VERSION}}_linux_amd64.zip"
        unzip -qO terraform_{{.LATEST_VERSION}}_linux_amd64.zip
        sudo mv terraform /usr/local/bin/terraform
        sudo chown root:root /usr/local/bin/terraform
        sudo chmod +x /usr/local/bin/terraform
    status:
      - command -v terraform

  install-terraform-ls:
    desc: "Install Terraform Language Server (terraform-ls)"
    run: once
    deps:
      - task: install-jq
    vars:
      LATEST_VERSION:
        sh: curl -s https://api.github.com/repos/hashicorp/terraform-ls/releases/latest | jq -r '.tag_name | ltrimstr("v")'
    cmds:
      - defer: rm -f terraform-ls_{{.LATEST_VERSION}}_linux_amd64.zip
      - defer: rm -f LICENSE.txt
      - >-
        curl -LO "https://releases.hashicorp.com/terraform-ls/{{.LATEST_VERSION}}/terraform-ls_{{.LATEST_VERSION}}_linux_amd64.zip"
        unzip -qO terraform-ls_{{.LATEST_VERSION}}_linux_amd64.zip
        sudo mv terraform-ls /usr/local/bin/terraform-ls
        sudo chown root:root /usr/local/bin/terraform-ls
        sudo chmod +x /usr/local/bin/terraform-ls
    status:
      - command -v terraform-ls

  start-terraform-ls:
    desc: "Start Terraform Language Server (terraform-ls)"
    run: once
    cmds:
      - terraform-ls serve

  install-aws:
    desc: "Install aws-cli"
    run: once
    cmds:
      - defer: rm -f awscliv2.zip
      - defer: rm -rf aws
      - |
        sudo rm -rf /usr/local/aws-cli
        curl -so "awscliv2.zip" "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
        unzip -qo awscliv2.zip
        sudo ./aws/install -b /usr/local/bin -i /usr/local/aws-cli -u >/dev/null 2>&1
        sudo chown root:root /usr/local/bin/aws
        sudo chmod +x /usr/local/bin/aws
    status:
      - command -v aws

  install-jq:
    desc: "Install jq"
    run: once
    vars:
      LATEST_VERSION:
        sh: |
          curl -s https://api.github.com/repos/jqlang/jq/releases/latest | grep '"tag_name":' | sed -E 's/.*"tag_name": "jq-([^"]+)".*/\1/'
      DOWNLOAD_URL: "https://github.com/jqlang/jq/releases/download/jq-{{.LATEST_VERSION}}/jq-linux64"
    cmds:
      - defer: rm -f jq-linux64
      - >-
        curl -sLO "{{.DOWNLOAD_URL}}"
        sudo mv jq-linux64 /usr/local/bin/jq
        sudo chown root:root /usr/local/bin/jq
        sudo chmod +x /usr/local/bin/jq
    status:
      - command -v jq

  install-combine:
    desc: "Install combine"
    run: once
    cmds:
      - >-
        sudo install -m 755 -o root -g root /workspaces/infrastructure/binaries/combine.sh /usr/bin/combine
    status:
      - command -v combine

  # ------------------------
  # Elixir / Erlang Installation
  # ------------------------
  elixir-install:
    desc: "Install Erlang and Elixir"
    silent: false
    vars:
      HOME:
        sh: echo $HOME
      LATEST_OTP_VERSION:
        sh: curl -s https://api.github.com/repos/erlang/otp/releases | jq -r '.[0] | .tag_name' | awk -F'-' '{print $2}'
      LATEST_OTP_MAJOR_VERSION:
        sh: echo {{.LATEST_OTP_VERSION}} | awk -F'.' '{print $1}'
      LATEST_ELIXIR_VERSION:
        sh: curl -s https://api.github.com/repos/elixir-lang/elixir/releases | jq -r '.[].tag_name | select(test("^v[0-9]+\\.[0-9]+\\.[0-9]+$")) | sub("^v"; "")' | head -n 1
      ELIXIR_PATH: "export PATH=$HOME/.elixir-install/installs/elixir/{{.LATEST_ELIXIR_VERSION}}-otp-{{.LATEST_OTP_MAJOR_VERSION}}/bin:$PATH"
      OTP_PATH: "export PATH=$HOME/.elixir-install/installs/otp/{{.LATEST_OTP_VERSION}}/bin:$PATH"
    cmds:
      - defer: rm -f install.sh
      - curl -fsSLO https://raw.githubusercontent.com/elixir-lang/elixir-lang.github.com/main/install.sh -o install.sh
      - chmod +x install.sh
      - ./install.sh elixir@latest otp@latest
      - |
        if ! grep -q "{{.ELIXIR_PATH}}" "$HOME/.bashrc"; then
          echo '{{.ELIXIR_PATH}}' >> "$HOME/.bashrc"
          export PATH=$HOME/.elixir-install/installs/elixir/{{.LATEST_ELIXIR_VERSION}}-otp-{{.LATEST_OTP_MAJOR_VERSION}}/bin:$PATH
        fi
      - |
        if ! grep -q "{{.OTP_PATH}}" "$HOME/.bashrc"; then
          echo '{{.OTP_PATH}}' >> "$HOME/.bashrc"
          export PATH=$HOME/.elixir-install/installs/otp/{{.LATEST_OTP_VERSION}}/bin:$PATH
        fi
    status:
      - command -v ~/.elixir-install/installs/elixir/{{.LATEST_ELIXIR_VERSION}}-otp-{{.LATEST_OTP_MAJOR_VERSION}}/bin/elixir
      - command -v ~/.elixir-install/installs/otp/{{.LATEST_OTP_VERSION}}/bin/erl

  # -----------

  mix:dev:
    desc: "Run development server"
    silent: false
    cmds:
      - mix deps.get
      - mix clean
      - mix compile
      - mix phx.server

  mix:test:
    desc: "Run tests"
    silent: false
    aliases:
      - test
    cmds:
      - mix test

  mix:deps:
    desc: "Install dependencies"
    silent: false
    cmds:
      - mix deps.get

  mix:compile:
    desc: "Compile project"
    silent: false
    cmds:
      - mix compile

  mix:format:
    desc: "Format code"
    silent: false
    cmds:
      - mix format

  mix:clean:
    desc: "Clean project"
    silent: false
    cmds:
      - mix clean
